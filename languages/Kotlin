Kotlin

- statically-typed language, developed by JetBrains
- it's a language that it's compiled to bytecode using JVM
- conventionally, semicolons are not needed, but they can be used at the end of a statement


- Code snippet

	val top_level_name = "Global_Example"

	fun getSomething(something: String): String = println("getting $something")
	
	fun main() {
		var mutable_name: String? = "Example"
		val immutable_name: String = Example2"

		println("Hello Kotlin" + immutable_name)

		if(mutable_name != null) {
			println(mutable_name);
		}

		when(argument) {
			first_equals_condition -> println("hi when first condition")
			second_equals_condition -> println("hi when second condition")
			else -> { 
				println("hi when null")
			}
		}

		getSomething("sweet")

		val arr = arrayOf("Kotlin", "World")
		val ls = listOf("something", "else")
		val mp = mapOf(1 to "a", 2 to "b")

	}

	class Animal {

	}



- Variables & types
	- they can be mutable or immutable
		- var - a mutable variable

		- val - local, immutable variables
		      - produces an error when updated

	- they can be declared outside functions and classes
		- they are called "Top Level Variables"


	- by default, variables are non-nullable, and will throw an error when a null is assigned
		- to be nullable, the definition types should have a ? after it (ex: var t: String? = null)

	
	- an easier way to declare variables is to let Kotlin detect variable type
		- the variables declared this way are always non-nullable (standard syntax should be used for nullable)
		-	 ex: 
			- val immutable_name = "Example"

	- special types
		- Any - represents the root of every non-nullable class hierarchy (similar to Object in Java)
		      - nulls can be stored using the general notation Any?	
		- Unit - represents the void notation and it's optional when declaring functions
		- Nothing - it's used for the functions that will never return a normal value (eg: throwing an exception without being caught)



- Control instructions

	- if 
		if(condition) {
			println("write something")
		} else if(condition2) {
			println("write something else")
	      	} else {
			println("last time to write something")
	      	}

	- one-liner if
		  val result = if(condition) true else false
	
	- when
      		when(argument) {
        		first_equals_condition -> println("hi when first condition")
        		second_equals_condition -> println("hi when second condition")
        		else -> { 
          		println("hi when null")
        		}
      		}


	- for
      		for (item in items) {
        		println(item)
      		}

	- foreach
		- it is the default name for looped elements iterator

      		someArray.forEach {
        		println(it)
      		}

      		someArray.forEach { element ->
        		println(element)
      		}

	- foreach with index
      		someArray.forEachIndexed{ index, element -> 
        		println("$element on $index")
      		}



- Functions
	- functions can be defined outside classes and are called "top level functions"
	- functions can accept both positional arguments and named arguments that can have different positions (but they cannot be mixed)
		- example:
			fun getSomething(name: String, age: Integer) = print("$name: $age")
			
			getSomething("Alex", 22)
			getSomething(age=22, name="Alex")

	- functions accepts a default parameter value
		- example:
			fun getSomething(name: String = "Alex") = print("$name")
			getSomething()

	- basic function example:
		fun getSomething(something: String): String {
        		return "getting $something"
      		}
      		println(getSomething())

	- lambda example:
		val funct: () -> Unit = { println("Hello world") }
		funct()

		val funct = () -> println("Hello world")
		funct()

	- single expression function 
		fun getSomething(): String = "getting something'"



- Collections
	- are immutable by default
		- Immutable Collections
			- Array
				- example: 
					val arr = arrayOf("Kotlin", "World")

			- List
				- example:
					val ls = listOf("something", "else")
	
			- Map
				- example:
					val mp = mapOf(1 to "a", 2 to "b")

		- Mutable Collections
			- the declarations are the same as for immuttable collections, but they contains the "mutable" word in the beginning
			- example:
				- mutableArrayOf(), mutableListOf(), mutableMapOf()



- Keywords
	- vararg
		- similar to Java's ... notation
		- allows a function to take a variable number of parameters as input
		- example:
			function getSomething(vararg items: String) = println(items.size)

	-  *arrayVariable
		- the spread variable, similar to JavaScripts' ... notation



- Classes
	- the "new" keyword is optional when instantiating a class
	- the default constructor can be defined right after the class definition
		- example: class Person(firstName: String, lastName: String)
	- like functions, the default constructor can accept default parameter values
	- the values can be defined either inside an init block or directly when defined
		- init block
			class Person(_firstName: String, _lastName: String) {
				val firstName: String
				val lastName: String

				init {
					firstName = _firstName
					lastName = _lastNAme
				}
			}

		- at definition
			class Person(_firstName: String, _lastName: String) {
				val firstName: String = _firstName
				val lastName: String = _lastName
			}

	- the properties can be defined and map directly in the default constructor
		- example
			class Person(val firstName: String, val lastName: String) {}

	- classes can define secondary constructors using the "constructor" keyword
		- example
			class Person(val firstName: String, val lastName: String) {
				constructor(): this("Peter", "Parker") {
					println("Secondary constructor")
				}
			}

	- Getters  & Setters
		- are accessed directly using the property name
		- example
			class Person(val firstName: String, val lastName: String) {
				var nickName: String? = null
					set(value) {
						field = value
					}
					get() {
						println("the value of nickName is $field")
					}
			}
			p1 = Person("Peter", "Parker")
			p1.nickName = "Spider-Man"
			println(p1.nickName)
