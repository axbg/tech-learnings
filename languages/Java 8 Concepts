Java 8 Concepts
    - Java 8 introduces 2 new major concepts: Lambdas and Streams

    Lambdas
        - are anonymous functions that can be stored inside a variable
        - syntax: (args) -> methodImplementation
        - can be used to process data
        - a lambda expression is not an object, but an object without an identity
        - can be used to implement methods of functional interfaces
            - a functional interface is an interface that has only one method definition, but can have multiple default implemented methods
                also the methods inherited from the Object class, such as equals, doesn't count
            - a functional interface can optionally be annotated with @FunctionalInterface
            
            - example: 
                @FunctionalInterface
                public interface ExampleInterface {
                    void printSomething(String s);
                }

                ExampleInterface example = String s -> System.out.println(s);
                //or, using method reference, also a new concept in Java8
                ExampleImplementatio example2 = System.out::println;

                example1.printSomething("hello");
        
        - examples of Java8 functional interfaces
            - Comparator
            - FileFilter
            - Runnable
            - Supplier<T>
            - Consumer<T> / BiConsumer<T, R> - takes one/two objects and executes a method on them
            - Function<T, R> / BiFunction<T, R, U> - takes one/two objects and returns a third object
            - Predicate<T> / BiPredicate<T, R> - takes one/two objects and returns a boolean
            - UnaryOperator<T> - takes one object and returns an object of the same type
            - BinaryOperator<T> - takes two objects and returns an object of the same type

            - when applied, they can be chained using methods that resembles logical operations:
                    List<String> strings = new ArrayList<>();
                    List<String> secondStrings = new ArrayList<>();

                    strings.addAll(Arrays.asList("one", "two", "three"));

                    Consumer<String> c1 = System.out::println;
                    Consumer<String> c2 = secondStrings::add;

                    strings.forEach(c1.andThen(c2));
                    System.out.println("secondStrings size: " + secondStrings.size());


        Streams
            - is an object that can define operations, doesn't hold any data and doesn't modify the initial object
            - are efficient for data processing, because it uses multithreading under the hood
            - built by the .stream() method implemented by the Collection interface
            - uses the Builder pattern, returning a stream everytime, so it allows chaining

            - can implement specific intermediary and terminal operations
            - to trigger the chain of methods invoked by a stream, at least one final operation should be present!

                - intermediary operations:
                    - map(Function T)
                        - returns a list that contains of objects of a different type
                        - used to apply transformation from a type to another

                    - flatMap(Function T)
                        -  returns a flattened stream composed of multiple streams

                    - filter(Predicate T)
                        - returns a list containing object of the same type
                        - used to filter some object based on a given criteria
                        - can take a Predicate as a parameter

                    - collect
                        - transforms the stream into a Collection and returns it

                    - peek(Consumer T)
                        - applies a method given as parameter and returns the stream

                - terminal operations
                    - forEach(Consumer T)
                        - parses the elements of a stream
                    
                    - reduce(Object o, BinaryOperator<T> t)
                        - the first parameter represents the initial value, if it's needed
                        - can apply basic operations: min(), max(), sum(), count()
                        - can apply operations that booleans: allMatch(), noneMatch(), anyMatch()
                        - can apply operations that return an optional: findFirst(), findAny()
                        - methods can already be applied by calling the method directly after the stream
                            stream().map(p -> p.getLastName()).allMatch(length < 20);
                        - example: 
                            stream.reduce(0, sum);
                            stream.min(Comparator.naturalOrder())


        Optionals
            - a new wrapper type that wraps an object and resembles the relationship between Integer and int
            - the method isPresent() returns true if the optional contains a value
            - the method .get() returns the wrapped object
            - the method .orElseThrow(Exception::new) throws an exception if an object is not present
